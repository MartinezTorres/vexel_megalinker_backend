#include "codegen.h"
#include "analysis.h"
#include "evaluator.h"
#include "expr_access.h"
#include "function_key.h"
#include "optimizer.h"
#include "constants.h"
#include <algorithm>
#include <functional>
#include <iomanip>
#include <cctype>
#include <tuple>
#include <sstream>
#include <deque>

namespace {
std::string escape_c_string(const std::string& input) {
    std::ostringstream oss;
    oss << std::hex << std::setfill('0');
    for (unsigned char c : input) {
        switch (c) {
            case '\\':
                oss << "\\\\";
                break;
            case '"':
                oss << "\\\"";
                break;
            case '\n':
                oss << "\\n";
                break;
            case '\r':
                oss << "\\r";
                break;
            case '\t':
                oss << "\\t";
                break;
            default:
                if (c >= 0x20 && c <= 0x7e) {
                    oss << static_cast<char>(c);
                } else {
                    oss << "\\x" << std::uppercase << std::setw(2) << static_cast<int>(c) << std::nouppercase;
                }
                break;
        }
    }
    return oss.str();
}

}

namespace vexel::megalinker_codegen {

static std::string render_annotation_comment(const std::vector<Annotation>& anns) {
    if (anns.empty()) return "";
    std::ostringstream os;
    os << "// Annotations:";
    for (const auto& ann : anns) {
        os << " [[" << ann.name;
        if (!ann.args.empty()) {
            os << "(";
            for (size_t i = 0; i < ann.args.size(); ++i) {
                if (i > 0) os << ", ";
                os << ann.args[i];
            }
            os << ")";
        }
        os << "]]";
    }
    return os.str();
}

CodeGenerator::CodeGenerator() : temp_counter(0), in_function(false) {
    output_stack.push(&body);
}

CCodegenResult CodeGenerator::generate(const Module& mod, const AnalyzedProgram& analyzed) {
    analyzed_program = &analyzed;

    header.str("");
    header.clear();
    body.str("");
    body.clear();
    generated_functions.clear();
    generated_vars.clear();
    current_ref_params.clear();
    facts = AnalysisFacts{};
    optimization = analyzed.optimization;
    current_reentrancy_key = 'N';
    current_module_id_expr = "0";
    current_bank_page = 'A';
    current_func_key.clear();
    current_variant_id.clear();
    current_variant_name_override.clear();
    current_instance_id = -1;
    current_func_symbol = nullptr;
    current_returns_aggregate = false;
    current_nonreentrant_frame_abi = false;
    current_nonreentrant_returns_value = false;
    current_nonreentrant_return_slot.clear();
    aggregate_out_param.clear();
    aggregate_out_type.clear();
    current_aggregate_params.clear();
    tuple_types.clear();
    expr_param_substitutions.clear();
    value_param_replacements.clear();
    underscore_var.clear();
    if (analyzed.forced_tuple_types) {
        for (const auto& pair : *analyzed.forced_tuple_types) {
            tuple_types[pair.first] = pair.second;
        }
    }
    comparator_cache.clear();
    comparator_definitions.clear();
    while (!output_stack.empty()) output_stack.pop();
    output_stack.push(&body);

    entry_instance_id = analyzed.entry_instance_id;

    emit_header("// Generated by Vexel compiler");
    emit_header("// https://github.com/vexel-lang/vexel");
    emit_header("// Dead code elimination: only reachable functions and referenced globals/types are generated");
    emit_header("");
    emit_header("#pragma once");
    emit_header("");
    emit_header("#include <stdint.h>");
    emit_header("#include <stdbool.h>");
    emit_header("#include <string.h>");
    emit_header("#include <stdlib.h>");
    emit_header("#include <math.h>");
    emit_header("");
    emit_header("#ifndef VX_MUTABLE");
    emit_header("#define VX_MUTABLE");
    emit_header("#endif");
    emit_header("#ifndef VX_NON_MUTABLE");
    emit_header("#define VX_NON_MUTABLE const");
    emit_header("#endif");
    emit_header("#ifndef VX_CONSTEXPR");
    emit_header("#define VX_CONSTEXPR const");
    emit_header("#endif");
    emit_header("#ifndef VX_REENTRANT");
    emit_header("#define VX_REENTRANT");
    emit_header("#endif");
    emit_header("#ifndef VX_NON_REENTRANT");
    emit_header("#define VX_NON_REENTRANT");
    emit_header("#endif");
    emit_header("#ifndef VX_REF_MASK");
    emit_header("#define VX_REF_MASK(x)");
    emit_header("#endif");
    emit_header("#ifndef VX_ENTRYPOINT");
    emit_header("#define VX_ENTRYPOINT");
    emit_header("#endif");
    emit_header("#ifndef VX_INLINE");
    emit_header("#define VX_INLINE");
    emit_header("#endif");
    emit_header("#ifndef VX_NOINLINE");
    emit_header("#define VX_NOINLINE");
    emit_header("#endif");
    emit_header("#ifndef VX_PURE");
    emit_header("#define VX_PURE");
    emit_header("#endif");
    emit_header("#ifndef VX_NO_GLOBAL_WRITE");
    emit_header("#define VX_NO_GLOBAL_WRITE");
    emit_header("#endif");
    emit_header("");

    if (analyzed.analysis) {
        facts = *analyzed.analysis;
    } else {
        throw CompileError("Internal error: backend received module without analysis facts",
                           SourceLocation());
    }

    validate_codegen_invariants(mod);

    gen_module(mod);

    CCodegenResult result;
    result.header = header.str();
    if (comparator_definitions.empty()) {
        result.source = body.str();
    } else {
        std::ostringstream combined;
        for (const auto& helper : comparator_definitions) {
            combined << helper << "\n";
        }
        combined << body.str();
        result.source = combined.str();
    }
    return result;
}

GeneratedFunctionInfo CodeGenerator::generate_single_function(const Module& mod,
                                                              StmtPtr func,
                                                              const AnalyzedProgram& analyzed,
                                                              const CodegenABI& options,
                                                              int instance_id,
                                                              const std::string& ref_key,
                                                              char reent_key,
                                                              const std::string& variant_name_override,
                                                              const std::string& variant_id_override) {
    (void)mod;
    analyzed_program = &analyzed;
    abi = options;

    header.str("");
    header.clear();
    body.str("");
    body.clear();
    generated_functions.clear();
    generated_vars.clear();
    current_ref_params.clear();
    current_aggregate_params.clear();
    facts = AnalysisFacts{};
    optimization = analyzed.optimization;
    current_reentrancy_key = reent_key;
    current_module_id_expr = "0";
    current_bank_page = 'A';
    current_func_key.clear();
    current_variant_id = variant_id_override;
    current_variant_name_override = variant_name_override;
    current_instance_id = instance_id;
    current_func_symbol = nullptr;
    current_returns_aggregate = false;
    current_nonreentrant_frame_abi = false;
    current_nonreentrant_returns_value = false;
    current_nonreentrant_return_slot.clear();
    aggregate_out_param.clear();
    aggregate_out_type.clear();
    tuple_types.clear();
    expr_param_substitutions.clear();
    value_param_replacements.clear();
    underscore_var.clear();
    if (analyzed.forced_tuple_types) {
        for (const auto& pair : *analyzed.forced_tuple_types) {
            tuple_types[pair.first] = pair.second;
        }
    }
    comparator_cache.clear();
    comparator_definitions.clear();
    while (!output_stack.empty()) output_stack.pop();
    output_stack.push(&body);
    temp_counter = 0;
    while (!available_temps.empty()) available_temps.pop();
    live_temps.clear();
    declared_temps.clear();

    entry_instance_id = analyzed.entry_instance_id;

    if (analyzed.analysis) {
        facts = *analyzed.analysis;
    } else {
        throw CompileError("Internal error: backend single-function emit missing analysis facts",
                           SourceLocation());
    }

    validate_codegen_invariants(func);

    if (func) {
        gen_func_decl(func, ref_key, reent_key);
    }

    if (!generated_functions.empty()) {
        return generated_functions.back();
    }
    return GeneratedFunctionInfo{};
}

void CodeGenerator::validate_codegen_invariants(const Module& mod) {
    const Program* program = analyzed_program ? analyzed_program->program : nullptr;

    auto set_instance = [&](int instance_id) {
        current_instance_id = instance_id;
    };

    auto validate_module = [&](const Module& module) {
        validate_codegen_invariants_impl(module.top_level, true, true);
    };

    if (program) {
        for (const auto& instance : program->instances) {
            set_instance(instance.id);
            const Module& module = program->modules[static_cast<size_t>(instance.module_id)].module;
            validate_module(module);
        }
    } else {
        set_instance(-1);
        validate_module(mod);
    }
}

void CodeGenerator::validate_codegen_invariants(StmtPtr func) {
    if (!func) return;
    std::vector<StmtPtr> stmts = {func};
    validate_codegen_invariants_impl(stmts, false, true);
}

void CodeGenerator::validate_codegen_invariants_impl(const std::vector<StmtPtr>& stmts,
                                                     bool use_facts,
                                                     bool top_level) {
    std::function<void(ExprPtr, bool)> validate_expr;
    std::function<void(StmtPtr, bool)> validate_stmt;

    validate_expr = [&](ExprPtr expr, bool value_required) {
        if (!expr) return;
        bool allow_untyped = expr->kind == Expr::Kind::ArrayLiteral && expr->elements.empty();
        if (value_required && !expr->is_expr_param_ref && !allow_untyped && !expr->type) {
            throw CompileError("Internal error: missing type before code generation", expr->location);
        }

        switch (expr->kind) {
            case Expr::Kind::Binary:
                validate_expr(expr->left, true);
                validate_expr(expr->right, true);
                break;
            case Expr::Kind::Unary:
            case Expr::Kind::Cast:
            case Expr::Kind::Length:
                validate_expr(expr->operand, true);
                break;
            case Expr::Kind::Call: {
                if (expr->operand && expr->operand->kind != Expr::Kind::Identifier) {
                    validate_expr(expr->operand, true);
                }
                for (const auto& rec : expr->receivers) {
                    validate_expr(rec, true);
                }
                const Symbol* callee = nullptr;
                if (expr->operand && expr->operand->kind == Expr::Kind::Identifier) {
                    callee = binding_for(expr->operand.get());
                }
                size_t param_index = 0;
                for (const auto& arg : expr->args) {
                    if (callee && callee->kind == Symbol::Kind::Function && callee->declaration &&
                        param_index < callee->declaration->params.size() &&
                        callee->declaration->params[param_index].is_expression_param) {
                        ++param_index;
                        continue;
                    }
                    validate_expr(arg, true);
                    ++param_index;
                }
                break;
            }
            case Expr::Kind::Index:
                validate_expr(expr->operand, true);
                if (!expr->args.empty()) {
                    validate_expr(expr->args[0], true);
                }
                break;
            case Expr::Kind::Member:
                validate_expr(expr->operand, true);
                break;
            case Expr::Kind::ArrayLiteral:
            case Expr::Kind::TupleLiteral:
                for (const auto& elem : expr->elements) {
                    validate_expr(elem, true);
                }
                break;
            case Expr::Kind::Block:
                for (const auto& st : expr->statements) {
                    validate_stmt(st, false);
                }
                validate_expr(expr->result_expr, value_required);
                break;
            case Expr::Kind::Conditional:
                if (analyzed_program && analyzed_program->constexpr_condition) {
                    auto cond = analyzed_program->constexpr_condition(expr->condition);
                    if (cond.has_value()) {
                        validate_expr(cond.value() ? expr->true_expr : expr->false_expr, value_required);
                        break;
                    }
                }
                validate_expr(expr->condition, true);
                validate_expr(expr->true_expr, value_required);
                validate_expr(expr->false_expr, value_required);
                break;
            case Expr::Kind::Assignment:
                if (!expr->creates_new_variable) {
                    validate_expr(expr->left, true);
                } else if (expr->left && expr->left->kind != Expr::Kind::Identifier) {
                    validate_expr(expr->left, true);
                }
                validate_expr(expr->right, true);
                break;
            case Expr::Kind::Range:
                validate_expr(expr->left, true);
                validate_expr(expr->right, true);
                break;
            case Expr::Kind::Iteration:
                validate_expr(loop_subject(expr), true);
                validate_expr(loop_body(expr), false);
                break;
            case Expr::Kind::Repeat:
                validate_expr(loop_subject(expr), true);
                validate_expr(loop_body(expr), false);
                break;
            default:
                break;
        }
    };

    validate_stmt = [&](StmtPtr stmt, bool is_top_level) {
        if (!stmt) return;
        switch (stmt->kind) {
            case Stmt::Kind::FuncDecl: {
                if (stmt->is_external) {
                    return;
                }
                Symbol* sym = binding_for(stmt);
                if (use_facts && sym && !facts.reachable_functions.count(sym)) {
                    return;
                }
                if (stmt->body) {
                    bool require_value = stmt->return_type || !stmt->return_types.empty();
                    if (stmt->body->kind == Expr::Kind::Block) {
                        for (const auto& bstmt : stmt->body->statements) {
                            validate_stmt(bstmt, false);
                        }
                        if (stmt->body->result_expr) {
                            validate_expr(stmt->body->result_expr, require_value);
                        }
                    } else {
                        validate_expr(stmt->body, require_value);
                    }
                }
                break;
            }
            case Stmt::Kind::VarDecl: {
                if (!stmt->var_type) {
                    throw CompileError("Internal error: variable '" + stmt->var_name +
                                       "' missing type before code generation", stmt->location);
                }
                bool skip = false;
                if (is_top_level && use_facts) {
                    bool is_exported = std::any_of(stmt->annotations.begin(), stmt->annotations.end(),
                                                   [](const Annotation& a) { return a.name == "export"; });
                    Symbol* sym = binding_for(stmt);
                    if (sym && !facts.used_global_vars.count(sym) && !is_exported) {
                        skip = true;
                    }
                }
                if (!skip && stmt->var_init) {
                    validate_expr(stmt->var_init, true);
                }
                break;
            }
            case Stmt::Kind::Expr:
                validate_expr(stmt->expr, false);
                break;
            case Stmt::Kind::Return:
                validate_expr(stmt->return_expr, true);
                break;
            case Stmt::Kind::ConditionalStmt:
                validate_expr(stmt->condition, true);
                validate_stmt(stmt->true_stmt, false);
                break;
            case Stmt::Kind::TypeDecl:
            case Stmt::Kind::Import:
            case Stmt::Kind::Break:
            case Stmt::Kind::Continue:
                break;
        }
    };

    for (const auto& stmt : stmts) {
        validate_stmt(stmt, top_level);
    }
}

void CodeGenerator::gen_module(const Module& mod) {
    const Program* program = analyzed_program ? analyzed_program->program : nullptr;

    auto set_instance = [&](int instance_id) {
        current_instance_id = instance_id;
    };

    auto for_instances = [&](auto&& fn) {
        if (program) {
            for (const auto& instance : program->instances) {
                set_instance(instance.id);
                const Module& module = program->modules[static_cast<size_t>(instance.module_id)].module;
                fn(module);
            }
        } else {
            set_instance(-1);
            fn(mod);
        }
    };

    // External function forward declarations
    for_instances([&](const Module& module) {
        for (const auto& stmt : module.top_level) {
            if (stmt->kind == Stmt::Kind::FuncDecl && stmt->is_external) {
                std::string func_name = stmt->func_name;
                if (!stmt->type_namespace.empty()) {
                    func_name = stmt->type_namespace + "::" + stmt->func_name;
                }
                bool is_reentrant = std::any_of(stmt->annotations.begin(), stmt->annotations.end(),
                                                [](const Annotation& a) { return a.name == "reentrant"; });
                bool is_nonreentrant = std::any_of(stmt->annotations.begin(), stmt->annotations.end(),
                                                   [](const Annotation& a) { return a.name == "nonreentrant"; });
                if (is_reentrant && is_nonreentrant) {
                    throw CompileError("Conflicting annotations: [[reentrant]] and [[nonreentrant]] on external function '" +
                                       stmt->func_name + "'", stmt->location);
                }
                std::string reent_prefix = is_reentrant ? "VX_REENTRANT " : "VX_NON_REENTRANT ";
                bool has_inline = std::any_of(stmt->annotations.begin(), stmt->annotations.end(),
                                              [](const Annotation& a) { return a.name == "inline"; });
                bool has_noinline = std::any_of(stmt->annotations.begin(), stmt->annotations.end(),
                                                [](const Annotation& a) { return a.name == "noinline"; });
                std::string label_prefix;
                if (!stmt->ref_params.empty()) {
                    std::string ref_key(stmt->ref_params.size(), 'M');
                    label_prefix += "VX_REF_MASK(\"" + ref_key + "\") ";
                }
                if (stmt->is_exported) {
                    label_prefix += "VX_ENTRYPOINT ";
                }
                if (has_noinline) {
                    label_prefix += "VX_NOINLINE ";
                } else if (has_inline) {
                    label_prefix += "VX_INLINE ";
                }
                std::string ret_type = stmt->return_type ? gen_type(stmt->return_type) : "void";
                emit_header(label_prefix + reent_prefix + ret_type + " " + mangle_name(func_name) + "(");
                for (size_t i = 0; i < stmt->params.size(); i++) {
                    if (i > 0) emit_header(", ");
                    std::string ptype = require_type(stmt->params[i].type,
                                                     stmt->params[i].location,
                                                     "parameter '" + stmt->params[i].name +
                                                     "' in external function '" + stmt->func_name + "'");
                    emit_header(ptype + " " + mangle_name(stmt->params[i].name));
                }
                emit_header(");");
            }
        }
    });
    emit_header("");

    // Type declarations (deduped by name)
    std::unordered_set<std::string> emitted_types;
    if (program) {
        for (const auto& mod_info : program->modules) {
            for (const auto& stmt : mod_info.module.top_level) {
                if (stmt->kind != Stmt::Kind::TypeDecl) continue;
                if (!facts.used_type_names.empty() && !facts.used_type_names.count(stmt->type_decl_name)) {
                    continue;
                }
                if (!emitted_types.insert(stmt->type_decl_name).second) {
                    continue;
                }
                gen_type_decl(stmt);
            }
        }
    } else {
        for (const auto& stmt : mod.top_level) {
            if (stmt->kind != Stmt::Kind::TypeDecl) continue;
            if (!facts.used_type_names.empty() && !facts.used_type_names.count(stmt->type_decl_name)) {
                continue;
            }
            if (!emitted_types.insert(stmt->type_decl_name).second) {
                continue;
            }
            gen_type_decl(stmt);
        }
    }

    // Note: tuple type declarations will be emitted after code generation

    // Forward declarations (only for reachable functions)
    for_instances([&](const Module& module) {
        for (const auto& stmt : module.top_level) {
            if (stmt->kind != Stmt::Kind::FuncDecl || stmt->is_external) {
                continue;
            }
            Symbol* sym = binding_for(stmt);
            if (!sym || sym->kind != Symbol::Kind::Function) continue;
            if (!facts.reachable_functions.count(sym)) {
                continue;
            }

            bool has_expr_params = false;
            for (const auto& param : stmt->params) {
                if (param.is_expression_param) {
                    has_expr_params = true;
                    break;
                }
            }
            if (has_expr_params) {
                continue;
            }

            std::string func_name = sym->name;
            std::string func_key = func_key_for(sym);

            std::string storage = stmt->is_exported ? "" : "static ";
            bool has_inline = std::any_of(stmt->annotations.begin(), stmt->annotations.end(),
                                          [](const Annotation& a) { return a.name == "inline"; });
            bool has_noinline = std::any_of(stmt->annotations.begin(), stmt->annotations.end(),
                                            [](const Annotation& a) { return a.name == "noinline"; });
            bool is_pure = false;
            bool no_global_write = false;
            {
                auto pure_it = facts.function_is_pure.find(sym);
                if (pure_it != facts.function_is_pure.end() && pure_it->second) {
                    is_pure = true;
                }
                auto gw_it = facts.function_writes_global.find(sym);
                if (gw_it != facts.function_writes_global.end() && !gw_it->second) {
                    no_global_write = true;
                }
            }

            std::string ret_type;
            bool returns_tuple = !stmt->return_types.empty();
            if (returns_tuple) {
                std::string tuple_name = std::string(TUPLE_TYPE_PREFIX) + std::to_string(stmt->return_types.size());
                for (const auto& t : stmt->return_types) {
                    tuple_name += "_";
                    if (t) {
                        tuple_name += t->to_string();
                    } else {
                        tuple_name += "unknown";
                    }
                }
                if (!tuple_types.count(tuple_name)) {
                    tuple_types[tuple_name] = stmt->return_types;
                }
                ret_type = mangle_name(tuple_name);
            } else {
                if (stmt->return_type) {
                    if (stmt->return_type->kind == Type::Kind::TypeVar) {
                        ret_type = "void";
                    } else {
                        ret_type = gen_type(stmt->return_type);
                    }
                } else {
                    if (stmt->body && stmt->body->type && stmt->body->type->kind != Type::Kind::TypeVar) {
                        ret_type = gen_type(stmt->body->type);
                    } else {
                        ret_type = "void";
                    }
                }
            }

            TypePtr return_type_ptr = nullptr;
            if (!returns_tuple) {
                if (stmt->return_type && stmt->return_type->kind != Type::Kind::TypeVar) {
                    return_type_ptr = stmt->return_type;
                } else if (stmt->body && stmt->body->type && stmt->body->type->kind != Type::Kind::TypeVar) {
                    return_type_ptr = stmt->body->type;
                }
            }

            bool returns_aggregate = abi.lower_aggregates && (returns_tuple || is_aggregate_type(return_type_ptr));
            std::string agg_out_type;
            if (returns_aggregate) {
                agg_out_type = ret_type;
                ret_type = "void";
            } else if (return_type_ptr && is_pointer_like(return_type_ptr)) {
                if (abi.func_return_ptr_kind && abi.func_return_ptr_kind(func_key) == PtrKind::Far) {
                    ret_type = "uint32_t";
                }
            }

            auto ref_keys = ref_variant_keys_for(stmt);
            auto reent_keys = reentrancy_keys_for(sym);
            for (const auto& reent_key : reent_keys) {
                std::string reent_prefix = (reent_key == 'R') ? "VX_REENTRANT " : "VX_NON_REENTRANT ";
                for (const auto& ref_key : ref_keys) {
                    std::string variant = variant_name(func_name, sym, reent_key, ref_key);
                    std::string codegen_name = mangle_name(variant) + instance_suffix(sym);
                    bool frame_abi_variant = (reent_key == 'N' && !stmt->is_exported);
                    std::string label_prefix;
                    if (!ref_key.empty()) {
                        label_prefix += "VX_REF_MASK(\"" + ref_key + "\") ";
                    }
                    if (stmt->is_exported) {
                        label_prefix += "VX_ENTRYPOINT ";
                    }
                    if (is_pure) {
                        label_prefix += "VX_PURE ";
                    }
                    if (no_global_write) {
                        label_prefix += "VX_NO_GLOBAL_WRITE ";
                    }
                    if (has_noinline) {
                        label_prefix += "VX_NOINLINE ";
                    } else if (has_inline) {
                        label_prefix += "VX_INLINE ";
                    }

                    if (frame_abi_variant) {
                        emit_header(label_prefix + reent_prefix + storage + "void " + codegen_name + "(void);");
                        continue;
                    }

                    emit_header(label_prefix + reent_prefix + storage + ret_type + " " + codegen_name + "(");

                    bool first_param = true;
                    if (returns_aggregate) {
                        emit_header(agg_out_type + "* __vx_out");
                        first_param = false;
                    }

                    for (size_t i = 0; i < stmt->ref_params.size(); i++) {
                        if (!first_param) emit_header(", ");
                        first_param = false;

                        std::string ref_type;
                        TypePtr ref_type_ptr = resolve_ref_param_type_or_fail(stmt, i);
                        bool by_ref = true;
                        if (!ref_key.empty() && i < ref_key.size()) {
                            by_ref = ref_key[i] == 'M';
                        }
                        if (abi.lower_aggregates && ref_type_ptr && is_aggregate_type(ref_type_ptr)) {
                            by_ref = true;
                        }
                        if (ref_type_ptr) {
                            ref_type = gen_type(ref_type_ptr);
                        } else if (!stmt->type_namespace.empty() && i == 0) {
                            ref_type = mangle_name(stmt->type_namespace);
                        } else {
                            ref_type = "void";
                        }

                        if (by_ref) {
                            ref_type += "*";
                        } else if (ref_type == "void") {
                            ref_type = "void*";
                        }

                        emit_header(ref_type + " " + mangle_name(stmt->ref_params[i]));
                    }

                    for (size_t i = 0; i < stmt->params.size(); i++) {
                        if (stmt->params[i].is_expression_param) continue;
                        if (!first_param) emit_header(", ");
                        first_param = false;
                        std::string ptype = require_type(stmt->params[i].type,
                                                         stmt->params[i].location,
                                                         "parameter '" + stmt->params[i].name +
                                                         "' in function '" + stmt->func_name + "'");
                        if (stmt->params[i].type && is_pointer_like(stmt->params[i].type)) {
                            Symbol* param_sym = binding_for(&stmt->params[i]);
                            if (ptr_kind_for_symbol(param_sym) == PtrKind::Far) {
                                ptype = "uint32_t";
                            }
                        }
                        if (abi.lower_aggregates && stmt->params[i].type && is_aggregate_type(stmt->params[i].type)) {
                            ptype = gen_type(stmt->params[i].type) + "*";
                        }
                        emit_header(ptype + " " + mangle_name(stmt->params[i].name));
                    }
                    emit_header(");");
                }
            }
        }
    });
    emit_header("");

    // Global variables and functions
    for_instances([&](const Module& module) {
        for (const auto& stmt : module.top_level) {
            gen_stmt(stmt);
        }
    });

    // Generate tuple type declarations (collected during code generation)
    // These are emitted at the end of gen_module after everything is processed
    // We need to insert them after includes but before function declarations
    std::vector<std::pair<std::string, std::vector<TypePtr>>> tuple_decls;
    if (!tuple_types.empty()) {
        for (const auto& pair : tuple_types) {
            if (!facts.used_type_names.empty() && !facts.used_type_names.count(pair.first)) {
                continue;
            }
            tuple_decls.push_back(pair);
        }
    }

    if (!tuple_decls.empty()) {
        std::sort(tuple_decls.begin(), tuple_decls.end(),
                  [](const auto& a, const auto& b) { return a.first < b.first; });

        // Save current header and body
        std::string header_str = header.str();
        std::string body_str = body.str();

        // Clear streams
        header.str("");
        header.clear();
        body.str("");
        body.clear();

        // Find the end of includes in header (after the empty line following includes)
        size_t includes_end = header_str.find("#include <math.h>");
        if (includes_end != std::string::npos) {
            includes_end = header_str.find('\n', includes_end);
            includes_end = header_str.find('\n', includes_end + 1) + 1; // Skip the empty line
        } else {
            includes_end = 0;
        }

        // Reconstruct header with tuple declarations inserted after includes
        header << header_str.substr(0, includes_end);

        emit_header("// Tuple type declarations");
        for (const auto& pair : tuple_decls) {
            const std::string& tuple_name = pair.first;
            const std::vector<TypePtr>& elem_types = pair.second;

            emit_header("typedef struct {");
            for (size_t i = 0; i < elem_types.size(); i++) {
                TypePtr elem = elem_types[i];
                std::string elem_type = require_type(elem,
                                                    elem ? elem->location : SourceLocation(),
                                                    "tuple element in '" + tuple_name + "'");
                emit_header("  " + elem_type + " __" + std::to_string(i) + ";");
            }
            emit_header("} " + mangle_name(tuple_name) + ";");
        }
        emit_header("");

        // Append rest of header
        header << header_str.substr(includes_end);

        // Restore body section
        body << body_str;
    }

}


void CodeGenerator::gen_stmt(StmtPtr stmt) {
    switch (stmt->kind) {
        case Stmt::Kind::FuncDecl:
            {
                Symbol* sym = binding_for(stmt);
                if (!sym || sym->kind != Symbol::Kind::Function) {
                    break;
                }
                auto reent_keys = reentrancy_keys_for(sym);
                auto ref_keys = ref_variant_keys_for(stmt);
                for (const auto& reent_key : reent_keys) {
                    for (const auto& ref_key : ref_keys) {
                        gen_func_decl(stmt, ref_key, reent_key);
                    }
                }
            }
            break;
        case Stmt::Kind::TypeDecl:
            // Already generated
            break;
        case Stmt::Kind::VarDecl:
            gen_var_decl(stmt);
            break;
        case Stmt::Kind::Expr:
            if (stmt->expr) {
                // Special handling for assignment expressions that create new variables
                // Check the creates_new_variable flag set by typechecker
                if (stmt->expr->kind == Expr::Kind::Assignment &&
                    stmt->expr->left->kind == Expr::Kind::Identifier &&
                    stmt->expr->creates_new_variable) {

                    // Generate variable declaration with initialization
                    std::string var_type_str;

                    // Special handling for tuple-returning function calls
                    if (stmt->expr->right && stmt->expr->right->kind == Expr::Kind::Call &&
                        stmt->expr->right->operand && stmt->expr->right->operand->kind == Expr::Kind::Identifier) {

                        std::string func_name = stmt->expr->right->operand->name;
                        Symbol* sym = binding_for(stmt->expr->right->operand);

                        if (sym && sym->kind == Symbol::Kind::Function && sym->declaration &&
                            !sym->declaration->return_types.empty()) {
                            // This is a tuple-returning function
                            std::string tuple_name = std::string(TUPLE_TYPE_PREFIX) + std::to_string(sym->declaration->return_types.size());
                            for (const auto& t : sym->declaration->return_types) {
                                tuple_name += "_";
                                if (t) {
                                    tuple_name += t->to_string();
                                } else {
                                    tuple_name += "unknown";
                                }
                            }
                            var_type_str = mangle_name(tuple_name);
                        } else if (stmt->expr->right->type) {
                            var_type_str = gen_type(stmt->expr->right->type);
                        } else {
                            throw CompileError("Missing type for assignment-generated variable '" +
                                               stmt->expr->left->name + "'", stmt->expr->location);
                        }
                    } else if (stmt->expr->left && stmt->expr->left->type) {
                        // Use explicit type annotation from left side
                        var_type_str = gen_type(stmt->expr->left->type);
                    } else if (stmt->expr->right && stmt->expr->right->type) {
                        // Infer from right side
                        var_type_str = gen_type(stmt->expr->right->type);
                    } else {
                        throw CompileError("Missing type for assignment-generated variable '" +
                                           stmt->expr->left->name + "'", stmt->expr->location);
                    }

                    std::string var_name = mangle_name(stmt->expr->left->name);
                    if (Symbol* sym = binding_for(stmt->expr->left)) {
                        var_name += instance_suffix(sym);
                    }

                    // Special handling for array initialization
                    TypePtr var_type = stmt->expr->left->type ? stmt->expr->left->type : stmt->expr->type;
                    if (var_type && var_type->kind == Type::Kind::Array &&
                        stmt->expr->right->kind == Expr::Kind::ArrayLiteral) {
                        // Generate array declaration with inline initialization
                        std::string elem_type = gen_type(var_type->element_type);
                        std::string size_str = std::to_string(resolve_array_length(var_type, stmt->expr->location));
                        emit(elem_type + " " + var_name + "[" + size_str + "] = {");
                        {
                            VoidCallGuard guard(*this, false);
                            for (size_t i = 0; i < stmt->expr->right->elements.size(); i++) {
                                if (i > 0) emit(", ");
                                emit(gen_expr(stmt->expr->right->elements[i]));
                            }
                        }
                        emit("};");
                        break;
                    }

                    std::string rhs;
                    {
                        VoidCallGuard guard(*this, false);
                        rhs = gen_expr(stmt->expr->right);
                    }
                    emit(var_type_str + " " + var_name + " = " + rhs + ";");
                    // Release RHS temp if it's a temporary
                    if (rhs.rfind("tmp", 0) == 0 &&
                        (!stmt->expr->right || !stmt->expr->right->type ||
                         stmt->expr->right->type->kind != Type::Kind::Array)) {
                        release_temp(rhs);
                    }
                    break;
                }

                // Regular expression statement (including assignments to existing variables)
                {
                    VoidCallGuard guard(*this, true);
                    std::string expr_code = gen_expr(stmt->expr);
                    if (!expr_code.empty()) {
                        emit(expr_code + ";");
                    }
                }
            }
            break;
        case Stmt::Kind::Return:
            if (stmt->return_expr) {
                std::string ret_expr;
                {
                    VoidCallGuard guard(*this, false);
                    ret_expr = gen_expr(stmt->return_expr);
                }
                emit_return_stmt(ret_expr);
            } else {
                emit_return_stmt("");
            }
            break;
        case Stmt::Kind::Break:
            emit("break;");
            break;
        case Stmt::Kind::Continue:
            emit("continue;");
            break;
        case Stmt::Kind::ConditionalStmt:
            // Try compile-time evaluation for dead branch elimination
            {
                CTValue cond_val;
                if (try_evaluate(stmt->condition, cond_val)) {
                    // Compile-time constant condition
                    bool is_true = false;
                    if (std::holds_alternative<int64_t>(cond_val)) {
                        is_true = std::get<int64_t>(cond_val) != 0;
                    } else if (std::holds_alternative<bool>(cond_val)) {
                        is_true = std::get<bool>(cond_val);
                    } else if (std::holds_alternative<uint64_t>(cond_val)) {
                        is_true = std::get<uint64_t>(cond_val) != 0;
                    }

                    if (is_true) {
                        // Only generate true branch
                        gen_stmt(stmt->true_stmt);
                    }
                    // If false, generate nothing (dead branch eliminated)
                    break;
                }
            }

            // Runtime conditional
            {
                std::string cond_expr;
                {
                    VoidCallGuard guard(*this, false);
                    cond_expr = gen_expr(stmt->condition);
                }
                emit("if (" + cond_expr + ") {");
            }
            gen_stmt(stmt->true_stmt);
            emit("}");
            break;
        default:
            break;
    }
}

void CodeGenerator::gen_func_decl(StmtPtr stmt, const std::string& ref_key, char reent_key) {
    if (stmt->is_external) return;

    Symbol* sym = binding_for(stmt);
    if (!sym || sym->kind != Symbol::Kind::Function) {
        return;
    }

    std::string func_name = sym->name;
    std::string func_key = func_key_for(sym);
    std::string variant_id = variant_name(func_name, sym, reent_key, ref_key);

    if (!current_variant_name_override.empty()) {
        variant_id = current_variant_name_override;
        if (current_variant_id.empty()) {
            current_variant_id = variant_id;
        }
    } else {
        current_variant_id = variant_id;
    }

    current_reentrancy_key = reent_key;
    current_function_non_reentrant = (reent_key == 'N');
    std::string reent_prefix = (reent_key == 'R') ? "VX_REENTRANT " : "VX_NON_REENTRANT ";

    // Skip unreachable functions (dead code elimination)
    if (!facts.reachable_functions.count(sym)) {
        current_function_non_reentrant = false;
        current_reentrancy_key = 'N';
        current_nonreentrant_frame_abi = false;
        current_nonreentrant_returns_value = false;
        current_nonreentrant_return_slot.clear();
        return;
    }

    current_func_key = func_key;
    current_func_symbol = sym;
    if (abi.func_page) {
        current_bank_page = abi.func_page(func_key);
    } else {
        current_bank_page = 'A';
    }
    if (abi.func_module_id_expr) {
        current_module_id_expr = abi.func_module_id_expr(func_key, current_bank_page);
    } else {
        current_module_id_expr = "0";
    }

    bool has_inline = std::any_of(stmt->annotations.begin(), stmt->annotations.end(),
                                  [](const Annotation& a) { return a.name == "inline"; });
    bool has_noinline = std::any_of(stmt->annotations.begin(), stmt->annotations.end(),
                                    [](const Annotation& a) { return a.name == "noinline"; });
    bool is_pure = false;
    bool no_global_write = false;
    {
        auto pure_it = facts.function_is_pure.find(sym);
        if (pure_it != facts.function_is_pure.end() && pure_it->second) {
            is_pure = true;
        }
        auto gw_it = facts.function_writes_global.find(sym);
        if (gw_it != facts.function_writes_global.end() && !gw_it->second) {
            no_global_write = true;
        }
    }

    // Skip functions with expression parameters - they're inlined at call sites
    for (const auto& param : stmt->params) {
        if (param.is_expression_param) {
            current_function_non_reentrant = false;
            current_reentrancy_key = 'N';
            current_nonreentrant_frame_abi = false;
            current_nonreentrant_returns_value = false;
            current_nonreentrant_return_slot.clear();
            return;
        }
    }

    // Reset temporary state for new function
    while (!available_temps.empty()) available_temps.pop();
    live_temps.clear();
    declared_temps.clear();
    temp_counter = 0;

    // Track reference parameters for this function (mutable paths use pointers)
    current_ref_params.clear();
    current_aggregate_params.clear();
    for (size_t i = 0; i < stmt->ref_params.size(); i++) {
        bool by_ref = true;
        if (!ref_key.empty() && i < ref_key.size()) {
            by_ref = ref_key[i] == 'M';
        }
        TypePtr ref_type_ptr = resolve_ref_param_type_or_fail(stmt, i);
        if (abi.lower_aggregates && ref_type_ptr && is_aggregate_type(ref_type_ptr)) {
            by_ref = true;
            current_aggregate_params.insert(stmt->ref_params[i]);
        }
        if (by_ref) {
            current_ref_params.insert(stmt->ref_params[i]);
        }
    }
    for (const auto& param : stmt->params) {
        if (param.is_expression_param) continue;
        if (abi.lower_aggregates && param.type && is_aggregate_type(param.type)) {
            current_aggregate_params.insert(param.name);
        }
    }

    // Internal functions are static, exported functions are public
    std::string storage = stmt->is_exported ? "" : "static ";
    std::string attr;
    if (stmt->is_exported) {
        if (std::any_of(stmt->annotations.begin(), stmt->annotations.end(),
                        [](const Annotation& a) { return a.name == "hot"; })) {
            attr = "__attribute__((hot)) ";
        }
        if (std::any_of(stmt->annotations.begin(), stmt->annotations.end(),
                        [](const Annotation& a) { return a.name == "cold"; })) {
            attr = "__attribute__((cold)) ";
        }
    }

    // Handle tuple return types
    std::string ret_type;
    bool returns_tuple = !stmt->return_types.empty();
    if (returns_tuple) {
        std::string tuple_name = std::string(TUPLE_TYPE_PREFIX) + std::to_string(stmt->return_types.size());
        for (const auto& t : stmt->return_types) {
            tuple_name += "_";
            if (t) {
                tuple_name += t->to_string();
            } else {
                tuple_name += "unknown";
            }
        }
        if (!tuple_types.count(tuple_name)) {
            tuple_types[tuple_name] = stmt->return_types;
        }
        ret_type = mangle_name(tuple_name);
    } else {
        if (stmt->return_type) {
            if (stmt->return_type->kind == Type::Kind::TypeVar) {
                ret_type = "void";
            } else {
                ret_type = gen_type(stmt->return_type);
            }
        } else {
            if (stmt->body && stmt->body->type && stmt->body->type->kind != Type::Kind::TypeVar) {
                ret_type = gen_type(stmt->body->type);
            } else {
                ret_type = "void";
            }
        }
    }

    TypePtr return_type_ptr = nullptr;
    if (!returns_tuple) {
        if (stmt->return_type && stmt->return_type->kind != Type::Kind::TypeVar) {
            return_type_ptr = stmt->return_type;
        } else if (stmt->body && stmt->body->type && stmt->body->type->kind != Type::Kind::TypeVar) {
            return_type_ptr = stmt->body->type;
        }
    }

    current_returns_aggregate = false;
    aggregate_out_param.clear();
    aggregate_out_type.clear();

    if (abi.lower_aggregates && (returns_tuple || is_aggregate_type(return_type_ptr))) {
        current_returns_aggregate = true;
        aggregate_out_param = "__vx_out";
        aggregate_out_type = ret_type;
        ret_type = "void";
    } else if (return_type_ptr && is_pointer_like(return_type_ptr)) {
        if (abi.func_return_ptr_kind && abi.func_return_ptr_kind(func_key) == PtrKind::Far) {
            ret_type = "uint32_t";
        }
    }

    std::string codegen_name = mangle_name(variant_id) + instance_suffix(sym);
    current_nonreentrant_frame_abi = use_nonreentrant_frame_abi(stmt->is_exported);
    current_nonreentrant_returns_value = false;
    current_nonreentrant_return_slot.clear();

    std::vector<std::pair<std::string, std::string>> frame_params;
    frame_params.reserve(stmt->ref_params.size() + stmt->params.size());
    for (size_t i = 0; i < stmt->ref_params.size(); i++) {
        std::string ref_type;
        TypePtr ref_type_ptr = (i < stmt->ref_param_types.size()) ? stmt->ref_param_types[i] : nullptr;
        bool by_ref = true;
        if (!ref_key.empty() && i < ref_key.size()) {
            by_ref = ref_key[i] == 'M';
        }
        if (abi.lower_aggregates && ref_type_ptr && is_aggregate_type(ref_type_ptr)) {
            by_ref = true;
        }
        if (ref_type_ptr) {
            ref_type = gen_type(ref_type_ptr);
        } else if (!stmt->type_namespace.empty() && i == 0) {
            ref_type = mangle_name(stmt->type_namespace);
        } else {
            ref_type = "void";
        }
        if (by_ref) {
            ref_type += "*";
        } else if (ref_type == "void") {
            ref_type = "void*";
        }
        frame_params.emplace_back(ref_type, mangle_name(stmt->ref_params[i]));
    }
    for (size_t i = 0; i < stmt->params.size(); i++) {
        if (stmt->params[i].is_expression_param) continue;
        std::string ptype = require_type(stmt->params[i].type,
                                         stmt->params[i].location,
                                         "parameter '" + stmt->params[i].name +
                                         "' in function '" + stmt->func_name + "'");
        if (stmt->params[i].type && is_pointer_like(stmt->params[i].type)) {
            Symbol* param_sym = binding_for(&stmt->params[i]);
            if (ptr_kind_for_symbol(param_sym) == PtrKind::Far) {
                ptype = "uint32_t";
            }
        }
        if (abi.lower_aggregates && stmt->params[i].type && is_aggregate_type(stmt->params[i].type)) {
            ptype = gen_type(stmt->params[i].type) + "*";
        }
        frame_params.emplace_back(ptype, mangle_name(stmt->params[i].name));
    }

    if (current_nonreentrant_frame_abi) {
        emit("");
        for (size_t i = 0; i < frame_params.size(); ++i) {
            emit("static " + frame_params[i].first + " " +
                 nonreentrant_arg_slot_name(codegen_name, i) + ";");
        }

        if (current_returns_aggregate) {
            current_nonreentrant_returns_value = true;
            current_nonreentrant_return_slot = nonreentrant_ret_slot_name(codegen_name);
            emit("static " + aggregate_out_type + " " + current_nonreentrant_return_slot + ";");
            current_returns_aggregate = false;
        } else if (ret_type != "void") {
            current_nonreentrant_returns_value = true;
            current_nonreentrant_return_slot = nonreentrant_ret_slot_name(codegen_name);
            emit("static " + ret_type + " " + current_nonreentrant_return_slot + ";");
        }
    }

    bool prev_in_function = in_function;
    in_function = true;
    std::ostringstream func_stream;
    output_stack.push(&func_stream);

    emit("");
    std::string ann_comment = render_annotation_comment(stmt->annotations);
    if (!ann_comment.empty()) emit(ann_comment);
    std::string label_prefix;
    if (!ref_key.empty()) {
        label_prefix += "VX_REF_MASK(\"" + ref_key + "\") ";
    }
    if (stmt->is_exported) {
        label_prefix += "VX_ENTRYPOINT ";
    }
    if (is_pure) {
        label_prefix += "VX_PURE ";
    }
    if (no_global_write) {
        label_prefix += "VX_NO_GLOBAL_WRITE ";
    }
    if (has_noinline) {
        label_prefix += "VX_NOINLINE ";
    } else if (has_inline) {
        label_prefix += "VX_INLINE ";
    }
    if (current_nonreentrant_frame_abi) {
        emit(label_prefix + reent_prefix + storage + attr + "void " + codegen_name + "(void) {");
    } else {
        emit(label_prefix + reent_prefix + storage + attr + ret_type + " " + codegen_name + "(");

        bool first_param = true;
        if (current_returns_aggregate) {
            emit(aggregate_out_type + "* " + aggregate_out_param);
            first_param = false;
        }

        for (size_t i = 0; i < frame_params.size(); i++) {
            if (!first_param) emit(", ");
            first_param = false;
            emit(frame_params[i].first + " " + frame_params[i].second);
        }

        emit(") {");
    }

    if (current_nonreentrant_frame_abi) {
        for (size_t i = 0; i < frame_params.size(); ++i) {
            emit(frame_params[i].first + " " + frame_params[i].second +
                 " = " + nonreentrant_arg_slot_name(codegen_name, i) + ";");
        }
    }

    bool handled_body = false;

    if (stmt->body) {
        if (stmt->params.empty() && stmt->ref_params.empty()) {
            CTValue result;
            if (try_evaluate(stmt->body, result)) {
                if (std::holds_alternative<int64_t>(result)) {
                    emit_return_stmt(std::to_string(std::get<int64_t>(result)));
                    handled_body = true;
                } else if (std::holds_alternative<uint64_t>(result)) {
                    emit_return_stmt(std::to_string(std::get<uint64_t>(result)));
                    handled_body = true;
                } else if (std::holds_alternative<bool>(result)) {
                    emit_return_stmt(std::string(std::get<bool>(result) ? "1" : "0"));
                    handled_body = true;
                } else if (std::holds_alternative<double>(result)) {
                    emit_return_stmt(std::to_string(std::get<double>(result)));
                    handled_body = true;
                }
            }
        }

        if (!handled_body && stmt->body->kind == Expr::Kind::Block &&
            stmt->params.empty() && stmt->ref_params.empty()) {
            std::string optimized = gen_block_optimized(stmt->body);
            if (!optimized.empty()) {
                emit(optimized);
                handled_body = true;
            }
        }

        if (!handled_body) {
            std::string body_expr;
            if (stmt->return_type) {
                if (stmt->body && stmt->body->kind == Expr::Kind::Block) {
                    for (const auto& bstmt : stmt->body->statements) {
                        gen_stmt(bstmt);
                    }
                    if (stmt->body->result_expr) {
                        VoidCallGuard guard(*this, false);
                        body_expr = gen_expr(stmt->body->result_expr);
                        emit_return_stmt(body_expr);
                    }
                } else {
                    VoidCallGuard guard(*this, false);
                    body_expr = gen_expr(stmt->body);
                    emit_return_stmt(body_expr);
                }
            } else {
                VoidCallGuard guard(*this, true);
                body_expr = gen_expr(stmt->body);
                if (!body_expr.empty()) {
                    emit(body_expr + ";");
                }
            }
        }
    }

    if (!current_returns_aggregate && !stmt->return_type && stmt->return_types.empty() &&
        !abi.return_prefix.empty()) {
        emit_return_stmt("");
    }

    emit("}");

    current_function_non_reentrant = false;
    current_reentrancy_key = 'N';
    current_returns_aggregate = false;
    current_nonreentrant_frame_abi = false;
    current_nonreentrant_returns_value = false;
    current_nonreentrant_return_slot.clear();
    aggregate_out_param.clear();
    aggregate_out_type.clear();
    current_aggregate_params.clear();
    current_variant_name_override.clear();
    current_variant_id.clear();
    current_func_key.clear();
    current_func_symbol = nullptr;
    current_module_id_expr = "0";
    current_bank_page = 'A';
    
    output_stack.pop();
    in_function = prev_in_function;
    std::string func_code = func_stream.str();
    if (!func_code.empty()) {
        GeneratedFunctionInfo info;
        info.declaration = stmt;
        info.qualified_name = variant_id;
        info.c_name = codegen_name;
        info.storage = storage;
        info.code = func_code;
        generated_functions.push_back(std::move(info));
        body << func_code;
    }
}

void CodeGenerator::gen_type_decl(StmtPtr stmt) {
    std::string ann_comment = render_annotation_comment(stmt->annotations);
    if (!ann_comment.empty()) emit_header(ann_comment);
    emit_header("typedef struct {");
    for (const auto& field : stmt->fields) {
        std::string ftype = require_type(field.type,
                                         field.location,
                                         "field '" + field.name + "' in type '" + stmt->type_decl_name + "'");
        emit_header("  " + ftype + " " + mangle_name(field.name) + ";");
    }
    emit_header("} " + mangle_name(stmt->type_decl_name) + ";");
    emit_header("");

    type_map[stmt->type_decl_name] = mangle_name(stmt->type_decl_name);
}

void CodeGenerator::gen_var_decl(StmtPtr stmt) {
    bool is_local = in_function;
    bool is_exported = std::any_of(stmt->annotations.begin(), stmt->annotations.end(),
                                   [](const Annotation& a) { return a.name == "export"; });
    Symbol* sym = binding_for(stmt);
    if (!is_local && sym && !facts.used_global_vars.count(sym) && !is_exported) {
        return;
    }
    // Top-level mutable globals must be internal to the translation unit
    std::string storage = (!is_local && stmt->is_mutable) ? "static " : "";
    if (!is_local && is_exported && !stmt->is_mutable) {
        storage = "extern ";
    }
    std::ostringstream var_stream;
    output_stack.push(&var_stream);
    std::string ann_comment = render_annotation_comment(stmt->annotations);
    if (!ann_comment.empty()) {
        emit(ann_comment);
    }
    auto finalize = [&]() {
        output_stack.pop();
        std::string code = var_stream.str();
        if (is_local) {
            if (!output_stack.empty()) {
                *output_stack.top() << code;
            }
        } else {
            GeneratedVarInfo info;
            info.declaration = stmt;
            info.symbol = sym;
            info.code = code;
            generated_vars.push_back(std::move(info));
            if (!abi.multi_file_globals) {
                body << code;
            }
        }
    };

    std::string var_name = stmt->var_name;
    if (sym) {
        var_name += instance_suffix(sym);
    }

    std::string vtype = require_type(stmt->var_type,
                                     stmt->location,
                                     "variable '" + stmt->var_name + "'");
    if (stmt->var_type) {
        TypePtr resolved = resolve_type(stmt->var_type);
        if (resolved && is_pointer_like(resolved) && resolved->kind != Type::Kind::Array) {
            if (ptr_kind_for_symbol(sym) == PtrKind::Far) {
                vtype = "uint32_t";
            }
        }
    }
    std::string mutability = mutability_prefix(stmt);
    if (!is_local && is_exported) {
        if (stmt->var_type && stmt->var_type->kind == Type::Kind::Array) {
            std::string elem_type = gen_type(stmt->var_type->element_type);
            std::string size_str;
            if (stmt->var_type->array_size) {
                size_str = std::to_string(resolve_array_length(stmt->var_type, stmt->location));
            }
            std::string suffix = size_str.empty() ? "[]" : ("[" + size_str + "]");
            emit_header("extern " + mutability + elem_type + " " + mangle_name(var_name) + suffix + ";");
        } else {
            emit_header("extern " + mutability + vtype + " " + mangle_name(var_name) + ";");
        }
    }
    if (stmt->var_init) {
        // Special handling for array literals and ranges
            if (stmt->var_type && stmt->var_type->kind == Type::Kind::Array &&
            (stmt->var_init->kind == Expr::Kind::ArrayLiteral || stmt->var_init->kind == Expr::Kind::Range)) {

            std::string elem_type = gen_type(stmt->var_type->element_type);
            std::string size_str = std::to_string(resolve_array_length(stmt->var_type, stmt->location));

            // Handle range expansion
            if (stmt->var_init->kind == Expr::Kind::Range) {
                auto bounds = evaluate_range(stmt->var_init);
                if (bounds) {
                    int64_t start = bounds->first;
                    int64_t end = bounds->second;
                    if (start == end) {
                        throw CompileError("Range cannot produce an empty array", stmt->var_init->location);
                    }
                    int64_t count = (start < end) ? (end - start) : (start - end);
                    std::ostringstream init;
                    init << storage << mutability << elem_type << " " << mangle_name(var_name) << "[" << count << "] = {";
                    bool first = true;
                    if (start < end) {
                        for (int64_t i = start; i < end; ++i) {
                            if (!first) init << ", ";
                            first = false;
                            init << i;
                        }
                    } else {
                        for (int64_t i = start; i > end; --i) {
                            if (!first) init << ", ";
                            first = false;
                            init << i;
                        }
                    }
                    init << "};";
                    emit(init.str());
                    finalize();
                    return;
                }
            }

                // Handle array literal
                if (stmt->var_init->kind == Expr::Kind::ArrayLiteral) {
                    emit(storage + mutability + elem_type + " " + mangle_name(var_name) + "[" + size_str + "] = {");
                    {
                        VoidCallGuard guard(*this, false);
                        for (size_t i = 0; i < stmt->var_init->elements.size(); i++) {
                            if (i > 0) emit(", ");
                            emit(gen_expr(stmt->var_init->elements[i]));
                        }
                    }
                    emit("};");
                    finalize();
                    return;
                }
            }

            // Fallback for arrays initialized from existing arrays/expressions: allocate and copy
            if (stmt->var_type && stmt->var_type->kind == Type::Kind::Array) {
                std::string elem_type = gen_type(stmt->var_type->element_type);
                std::string size_str = std::to_string(resolve_array_length(stmt->var_type, stmt->location));
                emit(storage + mutability + elem_type + " " + mangle_name(var_name) + "[" + size_str + "];");
                std::string init_expr;
                {
                    VoidCallGuard guard(*this, false);
                    init_expr = gen_expr(stmt->var_init);
                }
                emit("memcpy(" + mangle_name(var_name) + ", " + init_expr + ", sizeof(" + mangle_name(var_name) + "));");
                finalize();
                return;
            }

            // Try compile-time evaluation for simple constants
            {
            CTValue result;
            if (try_evaluate(stmt->var_init, result)) {
                // Successfully evaluated at compile time
                std::string init_val;
                if (std::holds_alternative<int64_t>(result)) {
                    int64_t val = std::get<int64_t>(result);
                    // For integer types, ensure the value is in range for C
                    // Apply wrapping if needed
                    if (stmt->var_type && stmt->var_type->kind == Type::Kind::Primitive) {
                        switch (stmt->var_type->primitive) {
                            case PrimitiveType::I8:
                                val = static_cast<int8_t>(val);
                                break;
                            case PrimitiveType::I16:
                                val = static_cast<int16_t>(val);
                                break;
                            case PrimitiveType::I32:
                                val = static_cast<int32_t>(val);
                                break;
                            case PrimitiveType::U8:
                                val = static_cast<uint8_t>(val);
                                break;
                            case PrimitiveType::U16:
                                val = static_cast<uint16_t>(val);
                                break;
                            case PrimitiveType::U32:
                                val = static_cast<uint32_t>(val);
                                break;
                            default:
                                break;
                        }
                    }
                    init_val = std::to_string(val);
                } else if (std::holds_alternative<uint64_t>(result)) {
                    uint64_t val = std::get<uint64_t>(result);
                    // Apply wrapping for smaller unsigned types
                    if (stmt->var_type && stmt->var_type->kind == Type::Kind::Primitive) {
                        switch (stmt->var_type->primitive) {
                            case PrimitiveType::U8:
                                val = static_cast<uint8_t>(val);
                                break;
                            case PrimitiveType::U16:
                                val = static_cast<uint16_t>(val);
                                break;
                            case PrimitiveType::U32:
                                val = static_cast<uint32_t>(val);
                                break;
                            default:
                                break;
                        }
                    }
                    init_val = std::to_string(val);
                } else if (std::holds_alternative<double>(result)) {
                    init_val = std::to_string(std::get<double>(result));
                } else if (std::holds_alternative<std::string>(result)) {
                    init_val = "\"" + escape_c_string(std::get<std::string>(result)) + "\"";
                }
                emit(storage + mutability + vtype + " " + mangle_name(var_name) + " = " + init_val + ";");
                finalize();
                return;
            } else if (!stmt->is_mutable) {
                throw CompileError("Constant '" + stmt->var_name +
                                   "' cannot be evaluated at compile time (possible uninitialized access)",
                                   stmt->location);
            }
        }
        // Fallback to runtime evaluation (only for mutable variables)
        std::string init_expr;
        {
            VoidCallGuard guard(*this, false);
            init_expr = gen_expr(stmt->var_init);
        }
        emit(storage + mutability + vtype + " " + mangle_name(var_name) + " = " + init_expr + ";");
    } else {
        // No initializer - special handling for arrays
        if (stmt->var_type && stmt->var_type->kind == Type::Kind::Array) {
            std::string elem_type = gen_type(stmt->var_type->element_type);
            std::string size_str = std::to_string(resolve_array_length(stmt->var_type, stmt->location));
            emit(storage + mutability + elem_type + " " + mangle_name(var_name) + "[" + size_str + "];");
        } else {
            emit(storage + mutability + vtype + " " + mangle_name(var_name) + ";");
        }
    }

    finalize();
}

bool CodeGenerator::is_compile_time_init(StmtPtr stmt) const {
    if (!stmt || !stmt->var_init) return false;
    if (optimization && optimization->constexpr_inits.count(stmt.get())) return true;
    if (stmt->var_type && stmt->var_type->kind == Type::Kind::Array &&
        (stmt->var_init->kind == Expr::Kind::ArrayLiteral || stmt->var_init->kind == Expr::Kind::Range)) {
        return true;
    }
    CTValue result;
    return try_evaluate(stmt->var_init, result);
}

std::string CodeGenerator::mutability_prefix(StmtPtr stmt) const {
    Symbol* sym = binding_for(stmt);
    auto it = sym ? facts.var_mutability.find(sym) : facts.var_mutability.end();
    VarMutability kind = stmt->is_mutable ? VarMutability::Mutable : VarMutability::Constexpr;
    if (it != facts.var_mutability.end()) {
        kind = it->second;
    }
    switch (kind) {
        case VarMutability::Mutable:
            return "VX_MUTABLE ";
        case VarMutability::NonMutableRuntime:
            return "VX_NON_MUTABLE ";
        case VarMutability::Constexpr:
            return "VX_CONSTEXPR ";
        default:
            return "";
    }
}

std::string CodeGenerator::ref_variant_key(const ExprPtr& call, size_t ref_count) const {
    std::string key;
    key.reserve(ref_count);
    for (size_t i = 0; i < ref_count; i++) {
        bool is_mut = false;
        if (call && i < call->receivers.size()) {
            is_mut = receiver_is_mutable_arg(call->receivers[i]);
        }
        key.push_back(is_mut ? 'M' : 'N');
    }
    return key;
}

std::vector<std::string> CodeGenerator::ref_variant_keys_for(StmtPtr stmt) const {
    std::vector<std::string> keys;
    if (!stmt || stmt->ref_params.empty()) {
        keys.push_back("");
        return keys;
    }
    Symbol* sym = binding_for(stmt);
    if (sym) {
        auto it = facts.ref_variants.find(sym);
        if (it != facts.ref_variants.end()) {
            keys.assign(it->second.begin(), it->second.end());
        }
    }
    if (keys.empty()) {
        keys.push_back(std::string(stmt->ref_params.size(), 'M'));
    }
    std::sort(keys.begin(), keys.end());
    return keys;
}

std::string CodeGenerator::ref_variant_name(const std::string& func_name, const std::string& ref_key) const {
    if (ref_key.empty()) return func_name;
    bool all_mut = std::all_of(ref_key.begin(), ref_key.end(), [](char c) { return c == 'M'; });
    if (all_mut) return func_name;
    return func_name + "__ref" + ref_key;
}

std::vector<char> CodeGenerator::reentrancy_keys_for(const Symbol* func_sym) const {
    std::vector<char> keys;
    if (func_sym) {
        auto it = facts.reentrancy_variants.find(func_sym);
        if (it != facts.reentrancy_variants.end()) {
            keys.assign(it->second.begin(), it->second.end());
        }
    }
    if (keys.empty()) {
        keys.push_back('N');
    }
    std::sort(keys.begin(), keys.end());
    return keys;
}

std::string CodeGenerator::reentrancy_variant_name(const std::string& func_name, const Symbol* func_sym, char reent_key) const {
    auto it = func_sym ? facts.reentrancy_variants.find(func_sym) : facts.reentrancy_variants.end();
    if (it == facts.reentrancy_variants.end() || it->second.size() <= 1) {
        return func_name;
    }
    if (reent_key == 'R') {
        return func_name + "__reent";
    }
    return func_name + "__nonreent";
}

std::string CodeGenerator::variant_name(const std::string& func_name, const Symbol* func_sym,
                                        char reent_key, const std::string& ref_key) const {
    std::string name = reentrancy_variant_name(func_name, func_sym, reent_key);
    return ref_variant_name(name, ref_key);
}

bool CodeGenerator::receiver_is_mutable_arg(ExprPtr expr) const {
    return is_addressable_lvalue(expr) && is_mutable_lvalue(expr);
}

bool CodeGenerator::is_void_call(ExprPtr expr, std::string* name_out) const {
    if (!expr || expr->kind != Expr::Kind::Call) return false;
    if (!expr->operand || expr->operand->kind != Expr::Kind::Identifier) return false;
    Symbol* sym = binding_for(expr->operand);
    if (!sym || sym->kind != Symbol::Kind::Function || !sym->declaration) return false;
    if (sym->declaration->return_type || !sym->declaration->return_types.empty()) return false;

    if (name_out) {
        *name_out = expr->operand->name;
    }
    return true;
}

bool CodeGenerator::try_evaluate(ExprPtr expr, CTValue& out) const {
    if (!expr) return false;

    auto contains_mutable_identifier = [&](ExprPtr root) -> bool {
        std::function<bool(ExprPtr)> visit = [&](ExprPtr node) -> bool {
            if (!node) return false;
            switch (node->kind) {
                case Expr::Kind::Identifier: {
                    Symbol* sym = binding_for(node);
                    return sym && sym->is_mutable;
                }
                case Expr::Kind::Binary:
                    return visit(node->left) || visit(node->right);
                case Expr::Kind::Unary:
                case Expr::Kind::Cast:
                case Expr::Kind::Length:
                case Expr::Kind::Member:
                    return visit(node->operand);
                case Expr::Kind::Call:
                    if (visit(node->operand)) return true;
                    for (const auto& rec : node->receivers) {
                        if (visit(rec)) return true;
                    }
                    for (const auto& arg : node->args) {
                        if (visit(arg)) return true;
                    }
                    return false;
                case Expr::Kind::Index:
                    if (visit(node->operand)) return true;
                    for (const auto& arg : node->args) {
                        if (visit(arg)) return true;
                    }
                    return false;
                case Expr::Kind::ArrayLiteral:
                case Expr::Kind::TupleLiteral:
                    for (const auto& elem : node->elements) {
                        if (visit(elem)) return true;
                    }
                    return false;
                case Expr::Kind::Conditional:
                    return visit(node->condition) || visit(node->true_expr) || visit(node->false_expr);
                case Expr::Kind::Range:
                    return visit(node->left) || visit(node->right);
                default:
                    return false;
            }
        };
        return visit(root);
    };

    if (optimization && !contains_mutable_identifier(expr)) {
        auto it = optimization->constexpr_values.find(expr.get());
        if (it != optimization->constexpr_values.end()) {
            out = it->second;
            return true;
        }
    }

    if (!analyzed_program || !analyzed_program->try_evaluate) {
        return false;
    }

    int eval_instance_id = current_instance_id;
    if (eval_instance_id < 0 && analyzed_program->entry_instance_id >= 0) {
        eval_instance_id = analyzed_program->entry_instance_id;
    }
    if (eval_instance_id < 0) {
        return false;
    }

    return analyzed_program->try_evaluate(eval_instance_id, expr, out);
}

bool CodeGenerator::is_addressable_lvalue(ExprPtr expr) const {
    if (!expr) return false;
    switch (expr->kind) {
        case Expr::Kind::Identifier:
            return true;
        case Expr::Kind::Member:
        case Expr::Kind::Index:
            return is_addressable_lvalue(expr->operand);
        default:
            return false;
    }
}

bool CodeGenerator::is_mutable_lvalue(ExprPtr expr) const {
    if (!expr) return false;
    switch (expr->kind) {
        case Expr::Kind::Identifier:
            return expr->is_mutable_binding;
        case Expr::Kind::Member:
        case Expr::Kind::Index:
            return is_mutable_lvalue(expr->operand);
        default:
            return false;
    }
}

bool CodeGenerator::is_aggregate_type(TypePtr type) const {
    TypePtr resolved = resolve_type(type);
    if (!resolved) return false;
    if (resolved->kind == Type::Kind::Named) return true;
    return false;
}

bool CodeGenerator::is_pointer_like(TypePtr type) const {
    if (!type) return false;
    if (type->kind == Type::Kind::Array) return true;
    if (type->kind == Type::Kind::Primitive && type->primitive == PrimitiveType::String) return true;
    return false;
}

TypePtr CodeGenerator::resolve_type(TypePtr type) const {
    if (!type) return nullptr;
    if (analyzed_program && analyzed_program->resolve_type) {
        return analyzed_program->resolve_type(type);
    }
    return type;
}

TypePtr CodeGenerator::resolve_ref_param_type_or_fail(StmtPtr stmt, size_t index) const {
    if (!stmt) return nullptr;
    TypePtr type = (index < stmt->ref_param_types.size()) ? stmt->ref_param_types[index] : nullptr;
    if (!type) return nullptr;
    if (type->kind != Type::Kind::TypeVar) return type;

    TypePtr resolved = resolve_type(type);
    if (resolved && resolved->kind != Type::Kind::TypeVar) {
        return resolved;
    }

    std::string ref_name = (index < stmt->ref_params.size()) ? stmt->ref_params[index] : ("ref#" + std::to_string(index));
    throw CompileError("Internal error: unresolved receiver type '" + ref_name +
                       "' in function '" + stmt->func_name + "'", stmt->location);
}

Symbol* CodeGenerator::binding_for(const void* node) const {
    if (!analyzed_program || !analyzed_program->binding_for) return nullptr;
    return analyzed_program->binding_for(current_instance_id, node);
}

std::string CodeGenerator::instance_suffix(const Symbol* sym) const {
    if (!sym || sym->is_local) return "";
    if (sym->instance_id < 0 || sym->instance_id == entry_instance_id) return "";
    return "_s" + std::to_string(sym->instance_id);
}

std::string CodeGenerator::func_key_for(const Symbol* sym) const {
    if (!sym) return "";
    int key_id = (sym->instance_id == entry_instance_id) ? -1 : sym->instance_id;
    return reachability_key(sym->name, key_id);
}

int CodeGenerator::scope_id_for_symbol(const Symbol* sym) const {
    if (!sym) return -1;
    if (sym->is_local) return -1;
    if (sym->instance_id < 0 || sym->instance_id == entry_instance_id) return -1;
    return sym->instance_id;
}

PtrKind CodeGenerator::ptr_kind_for_expr(const ExprPtr& expr) const {
    if (!expr || !expr->type) return PtrKind::Ram;
    if (!is_pointer_like(expr->type)) return PtrKind::Ram;
    if (abi.expr_ptr_kind) {
        return abi.expr_ptr_kind(expr);
    }
    return PtrKind::Ram;
}

PtrKind CodeGenerator::ptr_kind_for_symbol(const std::string& name, int scope_id) const {
    if (!abi.symbol_ptr_kind) return PtrKind::Ram;
    return abi.symbol_ptr_kind(name, scope_id);
}

PtrKind CodeGenerator::ptr_kind_for_symbol(const Symbol* sym) const {
    if (!sym) return PtrKind::Ram;
    return ptr_kind_for_symbol(sym->name, scope_id_for_symbol(sym));
}

std::string CodeGenerator::c_type_for_expr(ExprPtr expr) {
    if (!expr || !expr->type) return "void";
    if (is_pointer_like(expr->type)) {
        if (ptr_kind_for_expr(expr) == PtrKind::Far) {
            return "uint32_t";
        }
    }
    return gen_type(expr->type);
}

bool CodeGenerator::expr_has_side_effects(ExprPtr expr) const {
    if (!expr) return false;
    switch (expr->kind) {
        case Expr::Kind::Call:
        case Expr::Kind::Assignment:
        case Expr::Kind::Process:
        case Expr::Kind::Resource:
            return true;
        case Expr::Kind::Binary:
            return expr_has_side_effects(expr->left) || expr_has_side_effects(expr->right);
        case Expr::Kind::Unary:
        case Expr::Kind::Cast:
        case Expr::Kind::Length:
            return expr_has_side_effects(expr->operand);
        case Expr::Kind::Conditional:
            return expr_has_side_effects(expr->condition) ||
                   expr_has_side_effects(expr->true_expr) ||
                   expr_has_side_effects(expr->false_expr);
        case Expr::Kind::Index:
        case Expr::Kind::Member:
            return expr_has_side_effects(expr->operand);
        case Expr::Kind::ArrayLiteral:
            for (const auto& el : expr->elements) {
                if (expr_has_side_effects(el)) return true;
            }
            return false;
        case Expr::Kind::TupleLiteral:
            for (const auto& el : expr->elements) {
                if (expr_has_side_effects(el)) return true;
            }
            return false;
        case Expr::Kind::Block:
            return true;
        case Expr::Kind::Iteration:
        case Expr::Kind::Repeat:
            return true;
        default:
            return false;
    }
}


} // namespace vexel::megalinker_codegen
